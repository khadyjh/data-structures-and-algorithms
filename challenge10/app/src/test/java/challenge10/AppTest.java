/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package challenge10;

import challenge10.Queue.Queue;
import challenge10.stack.Stack;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.function.Executable;

import java.util.EmptyStackException;
import java.util.NoSuchElementException;

import static org.junit.jupiter.api.Assertions.*;

class AppTest {
    @Test void appHasAGreeting() {
        App classUnderTest = new App();
        assertNotNull(classUnderTest.getGreeting(), "app should have a greeting");
    }

    ///////////////////////////////////////////// stack test ////////////////////////////////////////

    @Test
    @DisplayName("Can successfully push onto a stack")
    void pushTest(){
        Stack<Integer> stack=new Stack<>();
        stack.push(1);
        String exp="Stack{top=Node{value=1, next=null}}";


        assertEquals(exp,stack.toString());
    }

    @Test
    @DisplayName("Can successfully push multiple values onto a stack")
    void pushMultiTest(){
        Stack<Integer> stack=new Stack<>();
        stack.push(1);
        stack.push(2);
        stack.push(3);
        String exp="Stack{top=Node{value=3, next=Node{value=2, next=Node{value=1, next=null}}}}";


        assertEquals(exp,stack.toString());
    }

    @Test
    @DisplayName("Can successfully pop off the stack")
    void popTest(){
        Stack<Integer> stack=new Stack<>();
        stack.push(1);
        stack.push(2);
        stack.push(3);
        int exp=3;

        assertEquals(exp,stack.pop());
    }

    @Test
    @DisplayName("Can successfully empty a stack after multiple pops")
    void popMultiTest(){
        Stack<Integer> stack=new Stack<>();
        stack.push(1);
        stack.push(2);
        stack.push(3);
        stack.pop();
        stack.pop();
        stack.pop();
        String exp="Stack{top=null}";
        assertEquals(exp,stack.toString());
    }

    @Test
    @DisplayName("Can successfully peek the next item on the stack")
    void peekTest(){
        Stack<Integer> stack=new Stack<>();
        stack.push(1);
        stack.push(2);
        stack.push(3);
        stack.pop();
        stack.pop();
        stack.pop();
        String exp="Stack{top=null}";
        assertEquals(exp,stack.toString());
    }

    @Test
    @DisplayName("Can successfully instantiate an empty stack")
    void EmptyTest(){
        Stack<Integer> stack=new Stack<>();

        String exp="Stack{top=null}";
        assertEquals(exp,stack.toString());

    }

    @Test
    @DisplayName("Calling pop or peek on empty stack raises exception")
    void peekExceptionTest(){
        assertThrows(EmptyStackException.class, new Executable() {
            @Override
            public void execute() throws Throwable {

                Stack<Integer> stack=new Stack<>();

                stack.peek();
            }
        });
    }

    @Test
    @DisplayName("Calling pop or peek on empty stack raises exception")
    void popExceptionTest(){
        assertThrows(EmptyStackException.class, new Executable() {
            @Override
            public void execute() throws Throwable {

                Stack<Integer> stack=new Stack<>();

                stack.pop();
            }
        });
    }

    ///////////////////////////////////////////// Queue test ////////////////////////////////////////

    @Test
    @DisplayName("Can successfully enqueue into a queue")
    void enqueueTest(){
        Queue<Integer>queue=new Queue<>();
        queue.enqueue(1);
        String exp="Queue{front=Node{value=1, next=null}, rear=Node{value=1, next=null}, size=1}";
        assertEquals(exp,queue.toString());
    }

    @Test
    @DisplayName("Can successfully enqueue multiple values into a queue")
    void enqueueMultiTest(){
        Queue<Integer>queue=new Queue<>();
        queue.enqueue(1);
        queue.enqueue(2);
        queue.enqueue(3);
        String exp="Queue{front=Node{value=1, next=Node{value=2, next=Node{value=3, next=null}}}, rear=Node{value=3, next=null}, size=3}";
        assertEquals(exp,queue.toString());
    }

    @Test
    @DisplayName("Can successfully dequeue out of a queue the expected value")
    void dequeueTest(){
        Queue<Integer>queue=new Queue<>();
        queue.enqueue(3);//front
        queue.enqueue(2);
        queue.enqueue(1);//rear

        int exp=3;
        assertEquals(exp,queue.dequeue());
    }

    @Test
    @DisplayName("Can successfully peek into a queue, seeing the expected value")
    void peekQTest(){
        Queue<Integer>queue=new Queue<>();
        queue.enqueue(3);//front
        queue.enqueue(2);
        queue.enqueue(1);//rear

        int exp=3;
        assertEquals(exp,queue.peek());
    }

    @Test
    @DisplayName("Can successfully empty a queue after multiple dequeues")
    void dequeueMultiQTest(){
        Queue<Integer>queue=new Queue<>();
        queue.enqueue(3);//front
        queue.enqueue(2);
        queue.enqueue(1);//rear
        queue.dequeue();
        queue.dequeue();
        queue.dequeue();


        String exp="Queue{front=null, rear=Node{value=1, next=null}, size=0}";
        assertEquals(exp,queue.toString());
    }

    @Test
    @DisplayName("Can successfully instantiate an empty queue")
    void emptyTest(){
        Queue<Integer>queue=new Queue<>();

        String exp="Queue{front=null, rear=null, size=0}";
        assertEquals(exp,queue.toString());
    }

    @Test
    @DisplayName("Calling dequeue or peek on empty queue raises exception")
    void exceptionPeekTest(){

            NoSuchElementException exception=assertThrows(NoSuchElementException.class, new Executable() {
                @Override
                public void execute() throws Throwable {
                    Queue<Integer>queue=new Queue<>();

                    queue.peek();
                }
            });
    }

    @Test
    @DisplayName("Calling dequeue or peek on empty queue raises exception")
    void exceptionDequeueTest(){

        NoSuchElementException exception=assertThrows(NoSuchElementException.class, new Executable() {
            @Override
            public void execute() throws Throwable {
                Queue<Integer>queue=new Queue<>();

                queue.dequeue();
            }
        });
    }
}
