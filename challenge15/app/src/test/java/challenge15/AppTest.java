/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package challenge15;

import challenge15.data.BTNode;
import challenge15.structure.BinarySearchTree;
import challenge15.structure.BinaryTree;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;

import static org.junit.jupiter.api.Assertions.*;

class AppTest {

    @Test
    @DisplayName("Can successfully instantiate an empty tree")
    public void test1(){
        BinaryTree binaryTree=new BinaryTree();
      assertEquals("binary tree => null",binaryTree.toString());
    }

    @Test
    @DisplayName("Can successfully instantiate a tree with a single root node")
    public void test2(){
        BinaryTree binaryTree=new BinaryTree();
        binaryTree.setRoot(new BTNode(1));
        assertEquals("binary tree => 1 => ",binaryTree.toString());
    }

    @Test
    @DisplayName("For a Binary Search Tree, can successfully add a left child and right child properly to a node")
    public void test3(){
        BinarySearchTree<String> binarySearchTree=new BinarySearchTree<>();
        binarySearchTree.insert("hi");
        binarySearchTree.insert("welcome");
        binarySearchTree.insert("hello");



    }

    @Test
    @DisplayName("false for the contains method, given an existing or non-existing node value")
    public void test4(){
        BinarySearchTree<String> binarySearchTree=new BinarySearchTree<>();
        binarySearchTree.insert("hi");
        binarySearchTree.insert("welcome");
        binarySearchTree.insert("hello");

        assertFalse(binarySearchTree.search("no"));

    }

    @Test
    @DisplayName("false for the contains method, given an existing or non-existing node value")
    public void test5(){
     BinaryTree binaryTree=new BinaryTree();

        binaryTree.setRoot(new BTNode(1));

        binaryTree.getRoot().setLeft(new BTNode(2));
        binaryTree.getRoot().setRight(new BTNode(3));


        binaryTree.getRoot().getLeft().setLeft(new BTNode(20));
        binaryTree.getRoot().getLeft().setRight(new BTNode(30));


        ArrayList<Integer> arrayList=new ArrayList<>();
        arrayList.add(1);
        arrayList.add(2);
        arrayList.add(20);
        arrayList.add(30);
        arrayList.add(3);

        assertEquals(arrayList,binaryTree.preorderDepthFirst());

    }

    @Test
    @DisplayName("inorderDepthFirst")
    public void test6(){
        BinaryTree binaryTree=new BinaryTree();

        binaryTree.setRoot(new BTNode(1));

        binaryTree.getRoot().setLeft(new BTNode(2));
        binaryTree.getRoot().setRight(new BTNode(3));


        binaryTree.getRoot().getLeft().setLeft(new BTNode(20));
        binaryTree.getRoot().getLeft().setRight(new BTNode(30));


        ArrayList<Integer> arrayList=new ArrayList<>();
        arrayList.add(20);
        arrayList.add(2);
        arrayList.add(30);
        arrayList.add(1);
        arrayList.add(3);

        assertEquals(arrayList,binaryTree.inorderDepthFirst());

    }


    //////////////////////////////////////////////////////challenge16/////////////////////////////////////////////

    @Test
    @DisplayName(" max tree ")
    public void test10(){
        BinaryTree binaryTree=new BinaryTree();
        binaryTree.setRoot(new BTNode(1));

        binaryTree.getRoot().setLeft(new BTNode(2));
        binaryTree.getRoot().setRight(new BTNode(3));


        binaryTree.getRoot().getLeft().setLeft(new BTNode(20));
        binaryTree.getRoot().getLeft().setRight(new BTNode(30));
        assertEquals(30,binaryTree.maxTree());

    }

    @Test
    @DisplayName(" max tree empty ")
    public void test11(){
        BinaryTree binaryTree=new BinaryTree();

        assertEquals(0,binaryTree.maxTree());

    }





}
