/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package challenge30;

import challenge30.binaryTree.BinaryNode;
import challenge30.binaryTree.BinaryTree;
import challenge30.structure.HashMap;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

class AppTest {
    @Test void appHasAGreeting() {
        App classUnderTest = new App();
        assertNotNull(classUnderTest.getGreeting(), "app should have a greeting");
    }

    @Test
    @DisplayName("Setting a key/value to your hashtable results in the value being in the data structure")
    public void test1(){
        HashMap<String,String> hashMap=new HashMap<>();
        hashMap.put("key","value");
        hashMap.put("key1","value1");

        assertFalse(hashMap.isEmpty());

    }

    @Test
    @DisplayName("Retrieving based on a key returns the value stored")
    public void test2(){
        HashMap<String,String> hashMap=new HashMap<>();
        hashMap.put("key","value");
        hashMap.put("key1","value1");

        String key=hashMap.get("key");
        assertEquals(key,hashMap.get("key"));

    }

    @Test
    @DisplayName("Successfully returns null for a key that does not exist in the hashtable")
    public void test3(){
        HashMap<String,String> hashMap=new HashMap<>();
        hashMap.put("key","value");
        hashMap.put("key1","value1");

        assertNull(hashMap.get("name"));

    }

    @Test
    @DisplayName("Successfully returns a list of all unique keys that exist in the hashtable")
    public void test4(){
        HashMap<String,String> hashMap=new HashMap<>();
        hashMap.put("key","value");
        hashMap.put("key1","value1");

        String[] keys={"key1","key"};
        String[] result= hashMap.Keys().toArray(new String[0]);
        assertArrayEquals(keys,result);

    }

    @Test
    @DisplayName("Successfully handle a collision within the hashtable")
    public void test5(){
        HashMap<String,String> hashMap=new HashMap<>();
        hashMap.put("JAVA", "JAVA"); // at index 0
        hashMap.put("Amman", "Amman"); // at index 0
        assertFalse(hashMap.isEmpty());

    }

    @Test
    @DisplayName("Successfully retrieve a value from a bucket within the hashtable that has a collision")
    public void test6(){
        HashMap<String,String> hashMap=new HashMap<>();
        hashMap.put("JAVA", "JAVA"); // at index 0
        hashMap.put("Amman", "Amman"); // at index 0
       assertEquals("JAVA",hashMap.get("JAVA"));
       assertEquals("Amman",hashMap.get("Amman"));

    }

    @Test
    @DisplayName("Successfully hash a key to an in-range value")
    public void test7(){
        // array size 0-9
        HashMap<String,String> hashMap=new HashMap<>();
        hashMap.put("JAVA", "JAVA"); // at index 0
        hashMap.put("Amman", "Amman"); // at index 0

      int hashedIndex=hashMap.getBucketIndex("JAVA");
      int hashedIndex1=hashMap.getBucketIndex("Amman");

      assertTrue(hashedIndex>=0 && hashedIndex<10);
      assertTrue(hashedIndex1>=0 && hashedIndex1<10);

    }
    //////////////////////////////////////////////////// challenge 31 //////////////////////////////////
    @Test
    @DisplayName("normal case ")
    public void test8(){
        HashMap<String,Integer> hashMap=new HashMap<>();

        String result = hashMap.repeatedWord("Once upon a time, there was a brave princess who..");
        String exp="a";

        assertEquals(exp,result);

    }

    @Test
    @DisplayName("contains special character ")
    public void test9(){
        HashMap<String,Integer> hashMap=new HashMap<>();

        // have comma after first summer word (summer,)
        String result = hashMap.repeatedWord("It was a queer, sultry summer, the summer they electrocuted the Rosenbergs, and I didn’t know what I was doing in New York...");
        String exp="summer";

        assertEquals(exp,result);
    }

    @Test
    @DisplayName("contains special character ")
    public void test10(){
        HashMap<String,Integer> hashMap=new HashMap<>();

        // have Q mark after first summer word (summer?)
        String result = hashMap.repeatedWord("It was a queer, sultry summer? the summer they electrocuted the Rosenbergs, and I didn’t know what I was doing in New York...");
        String exp="summer";

        assertEquals(exp,result);
    }

    @Test
    @DisplayName("long text ")
    public void test11(){
        HashMap<String,Integer> hashMap=new HashMap<>();

        String result = hashMap.repeatedWord("It was the best of times," +
                " it was the worst of times, it was the age of wisdom," +
                " it was the age of foolishness, it was the epoch of belief," +
                " it was the epoch of incredulity, it was the season of Light," +
                " it was the season of Darkness, it was the spring of hope," +
                " it was the winter of despair, we had everything before us," +
                " we had nothing before us, we were all going direct to Heaven," +
                " we were all going direct the other way – in short, " +
                "the period was so far like the present period," +
                " that some of its noisiest authorities insisted on its being received, for good or for evil, " +
                "in the superlative degree of comparison only...");
        String exp="it";

        assertEquals(exp,result);
    }

    //////////////////////////////////////////////////// challenge 32 //////////////////////////////////

    @Test
    @DisplayName("test tree intersection")
    public void test12(){
        BinaryTree<Integer> tree1=new BinaryTree<>();

        //level 1
        tree1.setRoot(new BinaryNode<>(150));
        // level 2
        tree1.getRoot().setLeft(new BinaryNode<>(100));
        tree1.getRoot().setRight(new BinaryNode<>(250));
        // level 3
        tree1.getRoot().getLeft().setLeft(new BinaryNode<>(75));
        tree1.getRoot().getLeft().setRight(new BinaryNode<>(160));

        tree1.getRoot().getRight().setLeft(new BinaryNode<>(200));
        tree1.getRoot().getRight().setRight(new BinaryNode<>(350));

        //level 4
        tree1.getRoot().getLeft().getRight().setLeft(new BinaryNode<>(125));
        tree1.getRoot().getLeft().getRight().setRight(new BinaryNode<>(175));

        tree1.getRoot().getRight().getRight().setLeft(new BinaryNode<>(300));
        tree1.getRoot().getRight().getRight().setRight(new BinaryNode<>(500));


        BinaryTree<Integer> tree2=new BinaryTree<>();
        //level 1
        tree2.setRoot(new BinaryNode<>(42));
        // level 2
        tree2.getRoot().setLeft(new BinaryNode<>(100));
        tree2.getRoot().setRight(new BinaryNode<>(600));
        // level 3
        tree2.getRoot().getLeft().setLeft(new BinaryNode<>(15));
        tree2.getRoot().getLeft().setRight(new BinaryNode<>(160));

        tree2.getRoot().getRight().setLeft(new BinaryNode<>(200));
        tree2.getRoot().getRight().setRight(new BinaryNode<>(350));

        //level 4
        tree2.getRoot().getLeft().getRight().setLeft(new BinaryNode<>(125));
        tree2.getRoot().getLeft().getRight().setRight(new BinaryNode<>(175));

        tree2.getRoot().getRight().getRight().setLeft(new BinaryNode<>(4));
        tree2.getRoot().getRight().getRight().setRight(new BinaryNode<>(500));

       List<Integer> result = App.treeIntersection(tree1,tree2);

       List<Integer> exp=new ArrayList<>();
       exp.add(100);
       exp.add(160);
       exp.add(125);
       exp.add(175);
       exp.add(200);
       exp.add(350);
       exp.add(500);



       assertEquals(exp,result);
    }

}
